# возможность так организовать программный код,
# что даже в случае возникновения ошибки программа продолжит работу в штатном режиме

# try:
#     *ваш код*
# except Ошибка:
#     *Код отлова*
# else:
#     *Код, который выполнится, если в блоке try всё хорошо прошло*
# finally:
#     *Код, который выполнится по-любому*

# except ZeroDivisionError as e: # Добавляем тип именно той ошибки, которую хотим отловить.
#     print(e) # Выводим информацию об ошибке

# в блоке except отлавливается не только сам указанный класс, но и его потомки. Например:
# try:
#     raise ZeroDivisionError       # возбуждаем исключение ZeroDivisionError
# except ArithmeticError:           # ловим его родителя
#     print("Hello from arithmetic error")


# если что-то пошло не так, то мы просто забиваем и идём дальше по коду:
# try:
#     *код, который мог вызывать ошибку*
# except Exception:
#     pass


# Для того, чтобы грамотно отлавливать исключения и ничего не упустить надо:
# Отлавливать исключения от конкретного к абстрактному.

try:
    num=int(input("ins number: "))
    print("you inserted "+str(num))
except:
    print("you must insert number!")
print("thank you!")

# у каждой ошибки/исключения есть тип (или класс).
# В конструкции try-except можно использовать несколько блоков except,
# каждый из которых будет обрабатывать ошибки определенного типа.
# Шаблон try-except конструкции в этом случае такой:
# try:
#     # КОМАНДЫ
# except ТИП ОШИБКИ:
#     # КОМАНДЫ
# except ТИП ОШИБКИ:
#     # КОМАНДЫ
# except ТИП ОШИБКИ:
#     # КОМАНДЫ
# Существует довольно много типов ошибок (классов исключений).
# Например:
# ValueError связана с преобразованием введенного значения к целочисленному формату,
# NameError - попытка обратиться к несуществующей переменной,
# TypeError - при несовместимости типов, попытке выполнить некорректную операцию,
# ZeroDivisionError При попытке деления на ноль,
# IndexError Если неправильно указать индексэлемента списка,
# SyntaxError при попытке вычислить некорректное (в плане синтаксиса) выражение.

print("операции со списком чисел…")
try:
    nums=eval(input("ыыедите числовой список: "))
    print("получено значение: "+str(nums))
    a=int(nums[0])
    b=int(nums[3])
    print(str(a)+"/"+str(b)+"="+str(a/b))
except ValueError:
    print("ValueError: ошибка при преобразовании!")
except ZeroDivisionError:
    print("ZeroDivisionError: попытка деления на ноль!")
except TypeError:
    print("TypeError: недопустимая операция!")
except IndexError:
    print("IndexError: неверный индекс!")
except SyntaxError:
    print("SyntaxError: вычисление невозможно!")
except NameError:
    print("NameError: неверный идентификатор!")
except:
    print("неизвестная ошибка!")
print("программа завершена.")


# мы можем вызывать ошибки самостоятельно, с помощью конструкции raise.
# Используется это, как правило, для отладки кода и остановки программы в критических ситуациях.
age = int(input("How old are you?"))

if age > 100 or age <= 0:
    raise ValueError("Тебе не может быть столько лет")

print(f"Тебе {age} лет!")  # Возраст выводится, только если пользователь ввёл правильный возраст.

# отлавливать вызываемые с помощью raise ошибки тоже можно.

# Иногда может понадобиться написать собственное исключение:
class MyException(Exception):     # создаём пустой класс – исключения
    pass

try:
    raise MyException("message")  # поднимаем наше исключение
except MyException as e:          # ловим его за хвост как шкодливого котёнка
    print(e)                      # выводим информацию об исключении



class NonPositiveDigitException(ValueError):
    pass

class Square:
    def __init__(self, a):
        if a <= 0:
            raise NonPositiveDigitException('Неправильно указана сторона квадрата')