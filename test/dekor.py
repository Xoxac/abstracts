from defs import prin
#
# Функция высшего порядка — это функция, принимающая в качестве аргументов
# другие функции или возвращающая другую функцию в качестве результата.

# def my_func(inside_func):
#     inside_func()  # Вызов функции принятой в качестве аргумента

# Замыкание — это функция, в теле которой присутствуют ссылки на переменные,
# объявленные вне тела этой функции в окружающем коде и не являющиеся её аргументами.

# def make_adder(x):
#    def adder(n):
#        return x + n # захват переменной "x" из nonlocal области
#    return adder  # возвращение функции в качестве результата

# функция, которая будет к любому числу прибавлять пятёрку
# add_5 = make_adder(5)
# print(add_5(10))  # 15
# print(add_5(100))  # 105

# Декораторы предназначены для подключения любого дополнительного поведения к основной функции,
# называемой декорируемой функцией, которое может выполняться до,
# после или даже вместо основной функции. При этом исходный код декорируемой функции
# никак не затрагивается.

def my_decorator(a_function_to_decorate): # называем наш декоратор, потом можем вызывать его @my_decorator
    # Здесь мы определяем новую функцию - «обертку». Она нам нужна, чтобы выполнять
    # каждый раз при вызове оригинальной функции, а не только один раз
    def wrapper():
        # здесь поместим код, которые будет выполняться до вызова, потом вызов
        # оригинальной функции, потом код после вызова
        print("Я буду выполнен до основного вызова!")

        result = a_function_to_decorate()  # не забываем вернуть значение исходной функции

        print("Я буду выполнен после основного вызова!")
        return result

    return wrapper

def adder(arg):
    def inner(a):
        return arg+a
    return inner

ad5 = adder(5) # скип шаг и попадаем во вложенную функцию. Теперь к аргументу прибавляется 5.
print(adder(7)(3)) # print(ad5(3))

def dec(fun):
    def inner(*args, **kwargs):
        print("start")
        fun(*args, **kwargs)
        print("stop")
    return inner

@dec        #pr = dec(pr)
def pr(ime, prezime):
    print("Hi", ime, prezime)

pr("Chel", "Chelich")

def dek(f):
    def inner(*arg, **kwarg):
        print("_______________")
        f(*arg, **kwarg)
        print("_______________")
    return inner
prin = dek(prin)
prin("Задание 4.5.2")

# Напишите декоратор, который будет подсчитывать количество вызовов декорируемой функции.
# Для хранения переменной содержащей, количество вызовов, используйте
# nonlocal область декоратора.

def counter(fun):
    count = 0
    def inner(*arg, **kwarg):
        nonlocal count
        fun(*arg, **kwarg)
        count += 1
        print(count)
    return inner

prin = counter(prin)

prin("Задание 4.5.3")

# Напишите декоратор, который будет сохранять результаты выполнения декорируемой функции
# в словаре. Словарь должен находиться в nonlocal области в следующем формате:
# по ключу располагается аргумент функции, по значению результат работы функции,
# например, {n: f(n)}.

# И при повторном вызове функции будет брать значение из словаря, а не вычислять заново.
# То есть словарь можно считать промежуточной памятью на время работы программы,
# где будут храниться ранее вычисленные значения.

# Исходная функция, которую нужно задекорировать имеет следующий вид и выполняет
# простое умножение на число 123456789.:


def deco(func):    #Большая функция, запускается один раз при декорации
    dic = {}
    def inner(arg):  # Вложенная функция, запускаетс каждый раз, при вызове декоррованной функции
        nonlocal dic
        dic[arg] = func(arg)
        print(dic)
    return inner


def ymnozenije(n):
    return n * 123456789

deco_ymnozenije = deco(ymnozenije)


deco_ymnozenije(2)
deco_ymnozenije(5)
