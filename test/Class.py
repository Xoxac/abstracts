# С архитектурной точки зрения лучшие практики будут звучать так:

# Проанализируйте задачу и выявите обособленные области ответственности. Например, представление
# данных координат, преобразование данных формата А в формат Б и т.д.

# Поставьте каждой области ответственности определённую сущность (класс). Например, данные
# координат — класс Point2D, корзина покупателя — класс Chart и т.д.

# Продумайте API для класса:
# какие данные и как он будет получать на вход;
# какие данные и как он будет отдавать вовне;
# какие методы можно будет вызывать извне.

# Распределите классы по модулям (если требуется).

import datetime
import math

money = 0

def get_money():
    global money
    return money

# ГЕНЕРАТОР КЛАССОВ
class Product:
    max_quantity = 10000    # атрибут класса


    def __init__(self, name, category, quantity_in_stock, price):    # магический метод класса (конструктор)
        self.name = name
        self.category = category
        self.quantity_in_stock = quantity_in_stock
        self.price = price

    def buy(self):
        self.quantity_in_stock -= 1
        global money
        money += self.price
        return self.quantity_in_stock

    # ИНКАПСУЛЯЦИЯ
    def get_quant(self):    # добавляем геттер - специальный метод для получения поля
        return self.quantity_in_stock

    def set_quant(self, quant):    # добавляем сеттер - специальный метод для установки нового значения
        if isinstance(quant, int):
            if quant > 0:    # проверяем условия, что больше 0 и это целое число
                self.quantity_in_stock = quant

# НАСЛЕДОВАНИЕ
# новый класс создается не на «пустом месте», а на основе уже существующего.
# В результате наследования все поля и функции из базового класса неявным образом «наследуются» в производном классе.
# class ПроизводныйКласс (РодительскийКласс):
    # Тело класса
    # super().__init__ если нужно вызов конструктора родительского класса

class Food(Product):
    is_critical = True
    needs_to_be_refreshed = True
    refresh_frequency = datetime.timedelta(days=1)

potato = Product('potato', 'voce', 10, 5)
potato.set_quant(15)
print('potato: ', potato.get_quant())

eggs = Food("eggs", "food", 5, 10)
eggs.set_quant(10)
print('eggs: ', eggs.quantity_in_stock)

eggs.buy()
print(eggs.get_quant(), get_money())

# ИМПОРТ КЛАССОВ
# Классы также можно передавать в другие файлы с помощью импорта.

# Полиморфизм в коде — это когда определённая часть кода (чаще всего функция)
# может обрабатывать объекты разных классов, меняя поведение в зависимости от класса.

# Перегрузка представляет собой изменение поведения стандартного оператора или метода
# под особенности класса.
# __eq__ — определяет поведение оператора равенства ==;
# __str__ — определяет поведение функции str() или вызов внутри функции print().
class Dot:
    def __init__(self,x,y):
        self.x=x
        self.y=y

    def __eq__(self, other):    #
        return self.x == other.x and self.y == other.y

    def __str__(self):
        return f'Dot: {self.x, self.y}'

p1=Dot(1,2)
p2=Dot(1,2)
print(p1==p2)
print(str(p1))
print(p2)


# ДЕКОРАТОРЫ

# @staticmethod
# Статические методы — методы, которые не привязаны к конкретному объекту класса и
# являются общими для всего класса. Они ведут себя как обычные функции и не связаны с классом, в котором они определены
class StaticClass:    #метод bar не содержит элемента self, поэтому является статическим
    def bar():
            print("bar")

StaticClass.bar()
# Декоратор @staticmethod позволяет убрать ошибку из стр def bar():
class StaticClass:
   @staticmethod    # пометили метод декоратором
   def bar():
           print("bar")

StaticClass.bar()    # вызов метода от класса

# Фабрика (один из шаблонов ООП) — класс, который создает объекты других классов.
# class FiguresFactory:
#   @staticmethod
#   def createFugure(type, bounding_rect):
#      if type == Square:        #create square object
#      if type == Elipse:        #create elipse object
# Как работает фабрика:
# Определите интерфейс: Создайте абстрактный базовый класс или интерфейс, который определяет общие
# характеристики объектов, которые вы хотите создавать.
# Реализуйте конкретные классы: Создайте подклассы, которые наследуют от базового
# класса или реализуют интерфейс. Каждый подкласс будет представлять собой конкретный тип объекта, который вы хотите создавать.
# Определите фабричную функцию: Создайте функцию, которая принимает на вход код типа объекта и
# возвращает экземпляр соответствующего подкласса.


# @classmethod
# используется для определения методов класса. В отличие от обычных методов экземпляра,
# методы класса связаны с самим классом, а не с его экземплярами.
# используется для реализации и явного обозначения полиморфизма (полиморфизм — это разное
# поведение методов класса родителя в классах наследниках).
# Когда вы декорируете метод с помощью @classmethod, Python автоматически добавляет первый параметр cls в метод.
# Этот параметр ссылается на сам класс, когда метод вызывается.
class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y

  @classmethod
  def from_polar(self, r, theta):    # метод класса, который создает новый экземпляр Point из полярных координат
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    return Point(x, y)

p1 = Point(3, 4)
p2 = Point.from_polar(5, math.pi / 4)

print(p1)  # Point(3, 4)
print(p2)  # Point(5.0, 5.0)


# @property
# позволяет организовывать класс так, чтобы скрыть внутреннюю структуру класса
# от посторонних глаз. Декоратор @property не создает новых атрибутов. Он просто позволяет вам определять методы,
# которые будут вызываться при доступе и изменении существующих атрибутов.
class Point:
  def __init__(self, x, y):
    self.__x = x
    self.__y = y

  @property
  def x(self):
    """Возвращает значение x-координаты."""
    return self.__x

  @x.setter
  def x(self, new_x):
    """Устанавливает новое значение x-координаты."""
    self.__x = new_x

  @property
  def y(self):
    """Возвращает значение y-координаты."""
    return self.__y

  @y.setter
  def y(self, new_y):
    """Устанавливает новое значение y-координаты."""
    self.__y = new_y

p = Point(10, 20)

print(p.x)  # Выведет 10
p.x = 30
print(p.x)  # Выведет 30