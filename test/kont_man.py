import os

print(os.getcwd())

# Контекстный менеджер — структура в Python (класс или генератор), основывающаяся на главном принципе:
# при его открытии и закрытии срабатывает заранее написанный код.

# Открытие происходит при входе в блок с помощью ключевого слова with. Закрытие происходит, когда блок заканчивается.
# Например, на входе — открывается файл, на выходе — закрывается.
with open("file.txt", "r") as file:
    content = file.read()
    print(content)

# Чтобы написать контекстный менеджер, нужно:

# Создать класс и написать в нём метод __enter__.
# Код в этом методе будет выполняться при входе в контекстный менеджер (при создании объекта с ключевым словом with).

# Написать метод __exit__. Этот метод будет выполнять код, помещённый в него, на выходе.

# Добавить в этот метод три дополнительных аргумента помимо self — exc_type, exc_val, exc_tb.

from datetime import datetime
import time  # проверять действие измерителя будем с помощью библиотеки time


# суть этого измерителя заключается в том, что мы считаем разницу в секундах между открытием и
# закрытием контекстного менеджера:
class Timer:
    # этот метод вызывается при создании объекта класса.
    # Если вам не нужно ничего инициализировать, то просто оставьте его пустым
    def __init__(self):
        pass

    # этот метод вызывается при запуске с помощью with. Если вы хотите вернуть какой-то объект,
    # чтобы потом работать с ним в контекстном менеджере, как в примере с файлом,
    # то просто верните этот объект через return
    def __enter__(self):
        self.start = datetime.utcnow()
        return None

    # этот метод срабатывает при выходе из контекстного менеджера
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"Time passed: {(datetime.utcnow() - self.start).total_seconds()}")


with Timer():
    time.sleep(2)  # засыпаем на 2 секунды

# exc_type — это тип исключения, из-за которого вылетел контекстный менеджер.
# Если всё прошло успешно, то значение этого аргумента будет None.

# exc_val — сообщение в исключении. Аналогично: если всё прошло успешно, этот аргумент будет None.

# exc_tb — объект сообщения от интерпретатора. Лучшего его вообще не трогать

# возможность создания контекстных менеджеров через генераторы:
from contextlib import contextmanager


@contextmanager  # оборачиваем функцию в декоратор contextmanager
def timer():
    start = datetime.utcnow()
    yield  # если вам нужно что-то вернуть через контекстный менеджер, просто вставьте этот объект сюда.
    print(f"Time passed: {(datetime.utcnow() - start).total_seconds()}")


with timer():
    time.sleep(2)

# Контекстный менеджер вызывается с помощью ключевого слова with. Он может возвращать или не возвращать
# объект для работы. Например, если контекстный менеджер подразумевает работу с каким-либо объектом,
# то надо добавить в запись: as *var*, где var — имя переменной в данном контексте.

# Мы научились строить собственные контекстные менеджеры на основе классов.
# Для этого мы пишем класс со специальными
# методами def __enter__(self, …) и __exit__(self, exc_type, exc_val, exc_tb).
# __enter__ вызывается при входе в контекстный менеджер,
# __exit__ — при выходе (не забудьте добавить необходимые аргументы).

# Научились строить контекстные менеджеры на основе генераторов и декоратора contextmanager из библиотеки contextlib.